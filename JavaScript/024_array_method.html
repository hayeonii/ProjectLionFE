<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body>
    <script>
        let myObj = {
            val1 : 10,
            val2 : 30
            // property = key : value
        }

        // let fruit = (["메론", "수박"], ["포도", "체리"]);

        // // 배열안 배열일때 ([].[])
        // let fish = ["정어리", "고등어", "참치"]
        // //일반적 배열 방법 []
        // let myobj = { val1: 10, val2: 30 }
        // //키와 value가 있을때 {}

        let myarry = []; // 이게 더 좋은 방법

        let myArray = new Array(5);

        console.log(myArray);

        let myArray2 = new Array(5, 3, 2);
        console.log(myArray2);

        myArray2[0] = 100;
        "hello"[2];

        console.log([1,2,3,4][5]); // undefined


        // slice()
        // 인수로 전달된 범위의 요소들을 복사하여 배열로 반환
        // 원본 배열을 변경하지 않는다
        // 복사를 종료할 인덱스 -1까지 복사됨
        const cafe2 = ['coffee', 'cake', 'tea', 'cookie']

        cafe2.slice(1, 3);
        //expected output: ['cake', 'tea']

        cafe2.slice(2);
        //expected output: ['tea', 'cookie']

        cafe2.slice(-2, -1);
        //expected output: ['tea']
    
        cafe2.slice(0, -2);
        //expected output: ['coffee', 'cake']
            

        // reverse()
        // 배열의 순서를 반대로 뒤집기
        // 원본 배열이 변경됨



        // indexOf()
        const cafe = ['tea', 'coffee', 'tea','cake', 'tea', 'cookie'];
        console.log(cafe.indexOf());
        // 왼쪽부터 탐색해 가장 처음 만나는 요소 반환
        // 인수로 전달할 요소가 존재하지 않으면 -1 반환
        // 두번째 매개변수는 검색을 시작할 인덱스

        // includes()
        // includes 함수는 boolean 값을 반환
        // 배열 안에 있는 값 찾을 때 유용
        // 두번째 인수로 검색을 시작할 인덱스를 전할 수 있음
        // indexOf() 사용하여도 되지만 indexOf() 사용하면 반환값이 -1인지, 배열에 NaN이 포함되어 있는지 확인할 수 없음

        // 문자열에서 사용할 수 있는 함수 - 메서드
        // 메서드를 사용할 수 있어서 체인이 됨
        // 반환값이 존재하지 않는 메서드 체이닝은 불가능하다
        // 체이닝: 메소드 연달아서 쓰는 것


        // join()
        const cafe3 = ['coffee', 'cake', 'tea', 'cookie']
        cafe3.join('/')
        // expected output: 'coffee/cake/tea/cookie'
        // 원본 배열의 모든 요소를 문자열로 반환 후, 구분자로 연결한 문자열로 반환

        // concat()
        const cafe4 = ['coffee'];  
        cafe4.concat(['cake']);
        //expected output: ['coffee', 'cake']
        // 인수로 전달된 값들을 원본 배열의 마지막 요소로 추가한 새로운 배열 반환
        // 원본 배열이 변경되지 않는다

        // find()
        // 하나의 요소라도 조건을 만족하는지 확인
        const arr2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        arr2.find(i => i > 5);
        //expected output: 6
        // 어떤 요소도 특정 조건에 부합하지 못하면 undefined 반환
        // find 결과값은 배열이 아닌 해당 요소값

        // filter()
        // 모든 요소가 조건을 만족하는지 확인
        const arr = [{
            'name' : 'title1',
            'contents' : 'contents1',
            'dataNum' : 1,
            'data' : [1, 2, 3]
        }, {
            'name' : 'title2',
            'contents' : 'contents2',
            'dataNum' : 2,
            'data' : [1, 2, 3]
        }, {
            'name' : 'title3',
            'contents' : 'contents3',
            'dataNum' : 3,
            'data' : [1, 2, 100]
        }, {
            'name' : 'title4',
            'contents' : 'contents4',
            'dataNum' : 4,
            'data' : [1, 2, 3]
        }, {
            'name' : 'title5',
            'contents' : 'contents5',
            'dataNum' : 5,
            'data' : [1, 2, 100]
        }];

        arr.filter(i => i.dataNum > 3);
        //expected output:
            // [{
            //     'name' : 'title4',
            //     'contents' : 'contents4',
            //     'dataNum' : 4
            // }, {
            //     'name' : 'title5',
            //     'contents' : 'contents5',
            //     'dataNum' : 5
            // }]
        // filter 결과값은 항상 배열
        // 중복된 값도 알아낼 수 있음
        // 자신을 호출한 배열의 모든 요소를 순회 -> 인수로 전달받은 콜백 함수 반복 호출 -> 반환값 true인 요소들만 구성된 새로운 배열 반환


        // map()
        const newArr = arr.map(function (i){
            return i.name
        });

        const studentList = [
            {
                id: 1, name: '원범', score: 'great'
            },
            {
                id: 2, name: '김진', score: 'nice'
            },
            {
                id: 3, name: '혜원', score: 'good'
            },
            {
                id: 4, name: '재현', score: 'too cool for school'
            }
        ]

        // const newStudentList = studentList.map(function(i){
        //     return i.name;
        // })

        const newStudentList = studentList.map(i => i.name);
        // map : 원하는 데이터를 가공하는데 목적이 있다, 원본 배열 변경하지 않음, 새로운 배열을 만든다
        // filter는 조건 메소드가 자체적으로 있고 map은 따로 없다(함수자리에 조건문을 걸면 메소드처럼 쓸 수 있다) 
    

        // forEach()
        // 각각의 요소 실행
        // 배열의 모든 요소 순회

        // map vs foreach : foreach - 결과값 그냥 반환, map - 결과값 배열로 반환


        // sort()
        // 배열 내 요소를 오름차순으로 정렬
        // 원본 배열 변경됨
        const arrNum = [13, 9, 10, 2];
        // arrNum.sort(); // 각각의 원소가 문자열로 취급되기 때문에 문자열 순서대로 정렬되고 있음
        arrNum.sort(function(a, b){
            console.log("a : "+a, "b : "+b);
            // return a - b;
            // b - a는 내림차순

            if (a<b){
                return -1
            } else if (b<a) {
                return 1
            } else {
                return 0
            } // 객체 정렬해야 할 때 조건문으로 사용이 가능
        })
        // 숫자 정렬을 위해서는 compare function(비교함수)를 집어 넣어 주어야 함

        // 9 - 13 ===> 음수일 때 더 큰수-작은수로 바꿔줌 ===> [9, 13, 10, 2]
        // 10 - 9 ===> 양수 ===> [9, 13, 10, 2]
        // 10 - 13 ===> 음수 ===> [9, 10, 13, 2]
        // 10 - 9 ===> 양수 ===> [0, 10, 13, 2]
        // 2 - 10 ===> 음수 ===> [9, 2, 10, 13] // 이미 10&13 비교하고 있기 때문에 한번에 움직임
        // 2 - 9 ===> 음수 ===> [2, 9, 10, 13]

        const studentList2 = [
            { id: 1, product: '연필', stock: 10 },
            { id: 2, product: '노트', stock: 100 },
            { id: 3, product: '지우개', stock: 5 },
            { id: 4, product: '볼펜', stock: 30 },
        ]

        studentList2.sort(function (a, b) {
            return a.stock - b.stock;
            // if (a.stock < b.stock){
            //     return -1
            // } else if (b.stock < a.stock) {
            //     return 1
            // } else {
            //     return 0
            // }
        })

        console.log(studentList2);

        // 분기문 사용 안하고 이렇게 사용해도 될 것 같음

    </script>
</body>
</html>